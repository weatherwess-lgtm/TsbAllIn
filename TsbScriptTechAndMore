-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ContentProvider = game:GetService("ContentProvider")
local RunService = game:GetService("RunService")
local ChatService = game:GetService("Chat")

-- Player references
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- Clean up and create persistent UI
local existingGui = playerGui:FindFirstChild("ForcassNotifierGui")
if existingGui then existingGui:Destroy() end

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "ForcassNotifierGui"
screenGui.ResetOnSpawn = false
screenGui.Parent = playerGui

-- Toggle button
local toggleButton = Instance.new("TextButton")
toggleButton.Size = UDim2.new(0, 120, 0, 50)
toggleButton.Position = UDim2.new(0.05, 0, 0.9, 0)
toggleButton.BackgroundColor3 = Color3.fromRGB(128, 0, 128)
toggleButton.TextColor3 = Color3.new(1, 1, 1)
toggleButton.Font = Enum.Font.GothamBold
toggleButton.TextSize = 20
toggleButton.Text = "OFF"
toggleButton.Parent = screenGui
Instance.new("UICorner", toggleButton).CornerRadius = UDim.new(0.5, 0)

-- Notifier function
local function showNotifier(text)
    local frame = Instance.new("Frame", screenGui)
    frame.Size = UDim2.new(0, 250, 0, 50)
    frame.Position = UDim2.new(0.5, 0, 0.15, 0)
    frame.AnchorPoint = Vector2.new(0.5, 0.5)
    frame.BackgroundColor3 = Color3.fromRGB(64, 0, 128)
    Instance.new("UICorner", frame).CornerRadius = UDim.new(0.25, 0)

    local label = Instance.new("TextLabel", frame)
    label.Size = UDim2.new(1, -20, 1, 0)
    label.Position = UDim2.new(0, 10, 0, 0)
    label.BackgroundTransparency = 1
    label.Text = text
    label.TextColor3 = Color3.new(1,1,1)
    label.Font = Enum.Font.GothamBold
    label.TextSize = 22
    label.TextXAlignment = Enum.TextXAlignment.Left

    task.delay(3, function()
        for i = 1, 20 do
            frame.BackgroundTransparency = i * 0.05
            label.TextTransparency = i * 0.05
            task.wait(0.1)
        end
        frame:Destroy()
    end)
end

showNotifier("Mady By Forcass Crd Kieuro")

-- Teleport-on-respawn logic
local healthConn, diedConn
local teleportOnRespawn = false
local deathPosition = Vector3.new()

local function disconnectConnections()
    if healthConn then healthConn:Disconnect() end
    if diedConn then diedConn:Disconnect() end
end

local function onCharacterAdded(character)
    local humanoid = character:WaitForChild("Humanoid")
    disconnectConnections()

    healthConn = humanoid.HealthChanged:Connect(function(health)
        if health <= 0 then
            local root = character:FindFirstChild("HumanoidRootPart")
            if root then
                deathPosition = root.Position
                teleportOnRespawn = true
            end
        end
    end)

    diedConn = humanoid.Died:Connect(function()
        local root = character:FindFirstChild("HumanoidRootPart")
        if root then
            deathPosition = root.Position
            teleportOnRespawn = true
        end
    end)
end

-- Preload aura animation
local auraAnimation = Instance.new("Animation")
auraAnimation.AnimationId = "rbxassetid://114586157428274"
ContentProvider:PreloadAsync({auraAnimation})

--------------------------------------------------------------------------------
-- Crown Effect (big -> spin 4s -> shrink -> disappear, with black particles)
--------------------------------------------------------------------------------
local CROWN_ASSET_ID = 82149395062733 -- catalog accessory ID you gave

local function buildCrownMeshFromAccessory(accessory)
    -- returns meshId, textureId (if found)
    if not accessory then return nil, nil end
    local handle = accessory:FindFirstChild("Handle")
    if not handle then return nil, nil end

    -- MeshPart-based accessory
    if handle:IsA("MeshPart") then
        return handle.MeshId, handle.TextureID
    end

    -- Part + SpecialMesh accessory
    if handle:IsA("Part") then
        local sm = handle:FindFirstChildOfClass("SpecialMesh")
        if sm then
            return sm.MeshId, sm.TextureId
        end
    end
    return nil, nil
end

local function crownEffect(character)
    local head = character:FindFirstChild("Head")
    if not head then return end

    -- Load the accessory, then extract real mesh/texture
    local ok, asset = pcall(function()
        return game:GetObjects("rbxassetid://"..tostring(CROWN_ASSET_ID))[1]
    end)
    local accessory
    if ok and asset then
        if asset:IsA("Accessory") then
            accessory = asset
        else
            accessory = asset:FindFirstChildWhichIsA("Accessory")
        end
    end

    local meshId, textureId = buildCrownMeshFromAccessory(accessory)

    -- Create visual crown part we can scale/animate
    local crown = Instance.new("Part")
    crown.Name = "VFX_Crown"
    crown.Anchored = false
    crown.CanCollide = false
    crown.Transparency = 0 -- must be visible!
    crown.Size = Vector3.new(2,2,2)
    crown.Parent = character

    -- Attach with Motor6D so we can rotate via C0
    local motor = Instance.new("Motor6D")
    motor.Name = "CrownMotor"
    motor.Part0 = head
    motor.Part1 = crown
    motor.C0 = CFrame.new(0, 2.2, 0) -- offset above head
    motor.Parent = head

    -- Mesh
    local mesh = Instance.new("SpecialMesh")
    mesh.Parent = crown
    if meshId then
        mesh.MeshType = Enum.MeshType.FileMesh
        mesh.MeshId = meshId
        if textureId and textureId ~= "" then
            mesh.TextureId = textureId
        end
    else
        -- Fallback simple cylinder if asset couldn't load
        mesh.MeshType = Enum.MeshType.Cylinder
    end
    mesh.Scale = Vector3.new(4,4,4) -- start BIG

    -- Black particles
    local att = Instance.new("Attachment")
    att.Parent = crown
    local p = Instance.new("ParticleEmitter")
    p.Parent = att
    p.Rate = 50
    p.Lifetime = NumberRange.new(1, 2)
    p.Speed = NumberRange.new(0.5, 2)
    p.Size = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 1.5),
        NumberSequenceKeypoint.new(1, 0)
    })
    p.Transparency = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 0.1),
        NumberSequenceKeypoint.new(1, 1)
    })
    p.Color = ColorSequence.new(Color3.fromRGB(0,0,0))
    p.SpreadAngle = Vector2.new(360,360)

    -- Spin for 4 seconds, then shrink away
    local alive = true
    local t = 0
    local spinConn
    spinConn = RunService.RenderStepped:Connect(function(dt)
        if not alive or not motor.Parent then return end
        t = t + dt
        -- rotate around Y via C0
        motor.C0 = CFrame.new(0, 2.2, 0) * CFrame.Angles(0, math.rad(t * 180), 0)
    end)

    -- After 4s, shrink gradually and clean up
    task.delay(4, function()
        for i = 1, 20 do
            mesh.Scale = mesh.Scale * 0.85
            task.wait(0.05)
        end
        alive = false
        if spinConn then spinConn:Disconnect() end
        if motor then motor:Destroy() end
        if crown then crown:Destroy() end
        if accessory then accessory:Destroy() end
    end)
end

local function onRespawn(character)
    -- Ensure required parts exist
    local humanoid = character:WaitForChild("Humanoid")
    local rootPart = character:WaitForChild("HumanoidRootPart")
    local animator = humanoid:FindFirstChildOfClass("Animator") or Instance.new("Animator", humanoid)

    -- Immediately teleport if enabled
    if teleportOnRespawn and deathPosition.Magnitude > 0 then
        rootPart.CFrame = CFrame.new(deathPosition)
        teleportOnRespawn = false
        deathPosition = Vector3.new()

        -- Show notifier and chat message
        showNotifier("But I Refuse")
        ChatService:Chat(character.Head, "I refuse to die to a weekling like you!", Enum.ChatColor.Red)
    end

    -- Play animation and aura IMMEDIATELY after spawn
    local animTrack = animator:LoadAnimation(auraAnimation)
    animTrack.Priority = Enum.AnimationPriority.Action
    animTrack:Play()

    -- Aura Highlight
    local auraHighlight = Instance.new("Highlight", character)
    auraHighlight.Adornee = character
    auraHighlight.FillTransparency = 1
    auraHighlight.OutlineTransparency = 0
    auraHighlight.OutlineColor = Color3.fromRGB(255, 0, 255)

    local colorTime = 0
    local highlightLoop = RunService.RenderStepped:Connect(function(dt)
        colorTime = colorTime + dt * 0.25
        auraHighlight.OutlineColor = Color3.fromRGB(
            math.sin(colorTime)*127 + 128,
            math.sin(colorTime+2)*127 + 128,
            math.sin(colorTime+4)*127 + 128
        )
    end)

    -- Particle effect
    local particles = {}
    for _, partName in ipairs({"UpperTorso","LowerTorso","HumanoidRootPart"}) do
        local part = character:FindFirstChild(partName)
        if part then
            local att = Instance.new("Attachment", part)
            local p = Instance.new("ParticleEmitter", att)
            p.Name = "DarkAura"
            p.Rate = 30
            p.Lifetime = NumberRange.new(1.2, 2)
            p.Speed = NumberRange.new(2, 5)
            p.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,3), NumberSequenceKeypoint.new(1,0)})
            p.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0.1), NumberSequenceKeypoint.new(1,1)})
            p.Color = ColorSequence.new(Color3.fromRGB(15,15,15))
            p.Rotation = NumberRange.new(0, 360)
            p.RotSpeed = NumberRange.new(-90, 90)
            p.SpreadAngle = Vector2.new(180,180)
            p.ZOffset = -1
            table.insert(particles, p)
        end
    end

    -- Crown effect
    crownEffect(character)

    -- Cleanup after 4 seconds (only aura bits; crown cleans itself)
    task.delay(4, function()
        if animTrack.IsPlaying then animTrack:Stop() end
        animTrack:Destroy()
        auraHighlight:Destroy()
        highlightLoop:Disconnect()
        for _, p in ipairs(particles) do
            if p then p:Destroy() end
        end
    end)

    -- Monitor health again
    onCharacterAdded(character)
end

-- Activation logic
local scriptActive = false
local characterAddedConnection

local function activateScript()
    if scriptActive then return end
    scriptActive = true
    toggleButton.Text = "ON"
    teleportOnRespawn = false
    deathPosition = Vector3.new()

    if not characterAddedConnection then
        characterAddedConnection = player.CharacterAdded:Connect(onRespawn)
    end
    if player.Character then onRespawn(player.Character) end

    showNotifier("Script loaded")
end

local function deactivateScript()
    if not scriptActive then return end
    scriptActive = false
    toggleButton.Text = "OFF"
    disconnectConnections()
    teleportOnRespawn = false
    deathPosition = Vector3.new()
    showNotifier("Script deactivated")
end

toggleButton.MouseButton1Click:Connect(function()
    if scriptActive then deactivateScript() else activateScript() end
end)

-- Initialize OFF
deactivateScript()
